package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i learngo-pockets/habits/api.HabitsClient -o ./mocks/habits_client_mock.go -n HabitsClientMock

import (
	context "context"
	mm_api "learngo-pockets/habits/api"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	grpc "google.golang.org/grpc"
)

// HabitsClientMock implements api.HabitsClient
type HabitsClientMock struct {
	t minimock.Tester

	funcCreateHabit          func(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption) (cp1 *mm_api.CreateHabitResponse, err error)
	inspectFuncCreateHabit   func(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption)
	afterCreateHabitCounter  uint64
	beforeCreateHabitCounter uint64
	CreateHabitMock          mHabitsClientMockCreateHabit

	funcListHabits          func(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption) (lp1 *mm_api.ListHabitsResponse, err error)
	inspectFuncListHabits   func(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption)
	afterListHabitsCounter  uint64
	beforeListHabitsCounter uint64
	ListHabitsMock          mHabitsClientMockListHabits
}

// NewHabitsClientMock returns a mock for api.HabitsClient
func NewHabitsClientMock(t minimock.Tester) *HabitsClientMock {
	m := &HabitsClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateHabitMock = mHabitsClientMockCreateHabit{mock: m}
	m.CreateHabitMock.callArgs = []*HabitsClientMockCreateHabitParams{}

	m.ListHabitsMock = mHabitsClientMockListHabits{mock: m}
	m.ListHabitsMock.callArgs = []*HabitsClientMockListHabitsParams{}

	return m
}

type mHabitsClientMockCreateHabit struct {
	mock               *HabitsClientMock
	defaultExpectation *HabitsClientMockCreateHabitExpectation
	expectations       []*HabitsClientMockCreateHabitExpectation

	callArgs []*HabitsClientMockCreateHabitParams
	mutex    sync.RWMutex
}

// HabitsClientMockCreateHabitExpectation specifies expectation struct of the HabitsClient.CreateHabit
type HabitsClientMockCreateHabitExpectation struct {
	mock    *HabitsClientMock
	params  *HabitsClientMockCreateHabitParams
	results *HabitsClientMockCreateHabitResults
	Counter uint64
}

// HabitsClientMockCreateHabitParams contains parameters of the HabitsClient.CreateHabit
type HabitsClientMockCreateHabitParams struct {
	ctx  context.Context
	in   *mm_api.CreateHabitRequest
	opts []grpc.CallOption
}

// HabitsClientMockCreateHabitResults contains results of the HabitsClient.CreateHabit
type HabitsClientMockCreateHabitResults struct {
	cp1 *mm_api.CreateHabitResponse
	err error
}

// Expect sets up expected params for HabitsClient.CreateHabit
func (mmCreateHabit *mHabitsClientMockCreateHabit) Expect(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption) *mHabitsClientMockCreateHabit {
	if mmCreateHabit.mock.funcCreateHabit != nil {
		mmCreateHabit.mock.t.Fatalf("HabitsClientMock.CreateHabit mock is already set by Set")
	}

	if mmCreateHabit.defaultExpectation == nil {
		mmCreateHabit.defaultExpectation = &HabitsClientMockCreateHabitExpectation{}
	}

	mmCreateHabit.defaultExpectation.params = &HabitsClientMockCreateHabitParams{ctx, in, opts}
	for _, e := range mmCreateHabit.expectations {
		if minimock.Equal(e.params, mmCreateHabit.defaultExpectation.params) {
			mmCreateHabit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateHabit.defaultExpectation.params)
		}
	}

	return mmCreateHabit
}

// Inspect accepts an inspector function that has same arguments as the HabitsClient.CreateHabit
func (mmCreateHabit *mHabitsClientMockCreateHabit) Inspect(f func(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption)) *mHabitsClientMockCreateHabit {
	if mmCreateHabit.mock.inspectFuncCreateHabit != nil {
		mmCreateHabit.mock.t.Fatalf("Inspect function is already set for HabitsClientMock.CreateHabit")
	}

	mmCreateHabit.mock.inspectFuncCreateHabit = f

	return mmCreateHabit
}

// Return sets up results that will be returned by HabitsClient.CreateHabit
func (mmCreateHabit *mHabitsClientMockCreateHabit) Return(cp1 *mm_api.CreateHabitResponse, err error) *HabitsClientMock {
	if mmCreateHabit.mock.funcCreateHabit != nil {
		mmCreateHabit.mock.t.Fatalf("HabitsClientMock.CreateHabit mock is already set by Set")
	}

	if mmCreateHabit.defaultExpectation == nil {
		mmCreateHabit.defaultExpectation = &HabitsClientMockCreateHabitExpectation{mock: mmCreateHabit.mock}
	}
	mmCreateHabit.defaultExpectation.results = &HabitsClientMockCreateHabitResults{cp1, err}
	return mmCreateHabit.mock
}

// Set uses given function f to mock the HabitsClient.CreateHabit method
func (mmCreateHabit *mHabitsClientMockCreateHabit) Set(f func(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption) (cp1 *mm_api.CreateHabitResponse, err error)) *HabitsClientMock {
	if mmCreateHabit.defaultExpectation != nil {
		mmCreateHabit.mock.t.Fatalf("Default expectation is already set for the HabitsClient.CreateHabit method")
	}

	if len(mmCreateHabit.expectations) > 0 {
		mmCreateHabit.mock.t.Fatalf("Some expectations are already set for the HabitsClient.CreateHabit method")
	}

	mmCreateHabit.mock.funcCreateHabit = f
	return mmCreateHabit.mock
}

// When sets expectation for the HabitsClient.CreateHabit which will trigger the result defined by the following
// Then helper
func (mmCreateHabit *mHabitsClientMockCreateHabit) When(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption) *HabitsClientMockCreateHabitExpectation {
	if mmCreateHabit.mock.funcCreateHabit != nil {
		mmCreateHabit.mock.t.Fatalf("HabitsClientMock.CreateHabit mock is already set by Set")
	}

	expectation := &HabitsClientMockCreateHabitExpectation{
		mock:   mmCreateHabit.mock,
		params: &HabitsClientMockCreateHabitParams{ctx, in, opts},
	}
	mmCreateHabit.expectations = append(mmCreateHabit.expectations, expectation)
	return expectation
}

// Then sets up HabitsClient.CreateHabit return parameters for the expectation previously defined by the When method
func (e *HabitsClientMockCreateHabitExpectation) Then(cp1 *mm_api.CreateHabitResponse, err error) *HabitsClientMock {
	e.results = &HabitsClientMockCreateHabitResults{cp1, err}
	return e.mock
}

// CreateHabit implements api.HabitsClient
func (mmCreateHabit *HabitsClientMock) CreateHabit(ctx context.Context, in *mm_api.CreateHabitRequest, opts ...grpc.CallOption) (cp1 *mm_api.CreateHabitResponse, err error) {
	mm_atomic.AddUint64(&mmCreateHabit.beforeCreateHabitCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateHabit.afterCreateHabitCounter, 1)

	if mmCreateHabit.inspectFuncCreateHabit != nil {
		mmCreateHabit.inspectFuncCreateHabit(ctx, in, opts...)
	}

	mm_params := &HabitsClientMockCreateHabitParams{ctx, in, opts}

	// Record call args
	mmCreateHabit.CreateHabitMock.mutex.Lock()
	mmCreateHabit.CreateHabitMock.callArgs = append(mmCreateHabit.CreateHabitMock.callArgs, mm_params)
	mmCreateHabit.CreateHabitMock.mutex.Unlock()

	for _, e := range mmCreateHabit.CreateHabitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateHabit.CreateHabitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateHabit.CreateHabitMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateHabit.CreateHabitMock.defaultExpectation.params
		mm_got := HabitsClientMockCreateHabitParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateHabit.t.Errorf("HabitsClientMock.CreateHabit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateHabit.CreateHabitMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateHabit.t.Fatal("No results are set for the HabitsClientMock.CreateHabit")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateHabit.funcCreateHabit != nil {
		return mmCreateHabit.funcCreateHabit(ctx, in, opts...)
	}
	mmCreateHabit.t.Fatalf("Unexpected call to HabitsClientMock.CreateHabit. %v %v %v", ctx, in, opts)
	return
}

// CreateHabitAfterCounter returns a count of finished HabitsClientMock.CreateHabit invocations
func (mmCreateHabit *HabitsClientMock) CreateHabitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateHabit.afterCreateHabitCounter)
}

// CreateHabitBeforeCounter returns a count of HabitsClientMock.CreateHabit invocations
func (mmCreateHabit *HabitsClientMock) CreateHabitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateHabit.beforeCreateHabitCounter)
}

// Calls returns a list of arguments used in each call to HabitsClientMock.CreateHabit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateHabit *mHabitsClientMockCreateHabit) Calls() []*HabitsClientMockCreateHabitParams {
	mmCreateHabit.mutex.RLock()

	argCopy := make([]*HabitsClientMockCreateHabitParams, len(mmCreateHabit.callArgs))
	copy(argCopy, mmCreateHabit.callArgs)

	mmCreateHabit.mutex.RUnlock()

	return argCopy
}

// MinimockCreateHabitDone returns true if the count of the CreateHabit invocations corresponds
// the number of defined expectations
func (m *HabitsClientMock) MinimockCreateHabitDone() bool {
	for _, e := range m.CreateHabitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateHabitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateHabitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateHabit != nil && mm_atomic.LoadUint64(&m.afterCreateHabitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateHabitInspect logs each unmet expectation
func (m *HabitsClientMock) MinimockCreateHabitInspect() {
	for _, e := range m.CreateHabitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HabitsClientMock.CreateHabit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateHabitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateHabitCounter) < 1 {
		if m.CreateHabitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HabitsClientMock.CreateHabit")
		} else {
			m.t.Errorf("Expected call to HabitsClientMock.CreateHabit with params: %#v", *m.CreateHabitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateHabit != nil && mm_atomic.LoadUint64(&m.afterCreateHabitCounter) < 1 {
		m.t.Error("Expected call to HabitsClientMock.CreateHabit")
	}
}

type mHabitsClientMockListHabits struct {
	mock               *HabitsClientMock
	defaultExpectation *HabitsClientMockListHabitsExpectation
	expectations       []*HabitsClientMockListHabitsExpectation

	callArgs []*HabitsClientMockListHabitsParams
	mutex    sync.RWMutex
}

// HabitsClientMockListHabitsExpectation specifies expectation struct of the HabitsClient.ListHabits
type HabitsClientMockListHabitsExpectation struct {
	mock    *HabitsClientMock
	params  *HabitsClientMockListHabitsParams
	results *HabitsClientMockListHabitsResults
	Counter uint64
}

// HabitsClientMockListHabitsParams contains parameters of the HabitsClient.ListHabits
type HabitsClientMockListHabitsParams struct {
	ctx  context.Context
	in   *mm_api.ListHabitsRequest
	opts []grpc.CallOption
}

// HabitsClientMockListHabitsResults contains results of the HabitsClient.ListHabits
type HabitsClientMockListHabitsResults struct {
	lp1 *mm_api.ListHabitsResponse
	err error
}

// Expect sets up expected params for HabitsClient.ListHabits
func (mmListHabits *mHabitsClientMockListHabits) Expect(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption) *mHabitsClientMockListHabits {
	if mmListHabits.mock.funcListHabits != nil {
		mmListHabits.mock.t.Fatalf("HabitsClientMock.ListHabits mock is already set by Set")
	}

	if mmListHabits.defaultExpectation == nil {
		mmListHabits.defaultExpectation = &HabitsClientMockListHabitsExpectation{}
	}

	mmListHabits.defaultExpectation.params = &HabitsClientMockListHabitsParams{ctx, in, opts}
	for _, e := range mmListHabits.expectations {
		if minimock.Equal(e.params, mmListHabits.defaultExpectation.params) {
			mmListHabits.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListHabits.defaultExpectation.params)
		}
	}

	return mmListHabits
}

// Inspect accepts an inspector function that has same arguments as the HabitsClient.ListHabits
func (mmListHabits *mHabitsClientMockListHabits) Inspect(f func(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption)) *mHabitsClientMockListHabits {
	if mmListHabits.mock.inspectFuncListHabits != nil {
		mmListHabits.mock.t.Fatalf("Inspect function is already set for HabitsClientMock.ListHabits")
	}

	mmListHabits.mock.inspectFuncListHabits = f

	return mmListHabits
}

// Return sets up results that will be returned by HabitsClient.ListHabits
func (mmListHabits *mHabitsClientMockListHabits) Return(lp1 *mm_api.ListHabitsResponse, err error) *HabitsClientMock {
	if mmListHabits.mock.funcListHabits != nil {
		mmListHabits.mock.t.Fatalf("HabitsClientMock.ListHabits mock is already set by Set")
	}

	if mmListHabits.defaultExpectation == nil {
		mmListHabits.defaultExpectation = &HabitsClientMockListHabitsExpectation{mock: mmListHabits.mock}
	}
	mmListHabits.defaultExpectation.results = &HabitsClientMockListHabitsResults{lp1, err}
	return mmListHabits.mock
}

// Set uses given function f to mock the HabitsClient.ListHabits method
func (mmListHabits *mHabitsClientMockListHabits) Set(f func(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption) (lp1 *mm_api.ListHabitsResponse, err error)) *HabitsClientMock {
	if mmListHabits.defaultExpectation != nil {
		mmListHabits.mock.t.Fatalf("Default expectation is already set for the HabitsClient.ListHabits method")
	}

	if len(mmListHabits.expectations) > 0 {
		mmListHabits.mock.t.Fatalf("Some expectations are already set for the HabitsClient.ListHabits method")
	}

	mmListHabits.mock.funcListHabits = f
	return mmListHabits.mock
}

// When sets expectation for the HabitsClient.ListHabits which will trigger the result defined by the following
// Then helper
func (mmListHabits *mHabitsClientMockListHabits) When(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption) *HabitsClientMockListHabitsExpectation {
	if mmListHabits.mock.funcListHabits != nil {
		mmListHabits.mock.t.Fatalf("HabitsClientMock.ListHabits mock is already set by Set")
	}

	expectation := &HabitsClientMockListHabitsExpectation{
		mock:   mmListHabits.mock,
		params: &HabitsClientMockListHabitsParams{ctx, in, opts},
	}
	mmListHabits.expectations = append(mmListHabits.expectations, expectation)
	return expectation
}

// Then sets up HabitsClient.ListHabits return parameters for the expectation previously defined by the When method
func (e *HabitsClientMockListHabitsExpectation) Then(lp1 *mm_api.ListHabitsResponse, err error) *HabitsClientMock {
	e.results = &HabitsClientMockListHabitsResults{lp1, err}
	return e.mock
}

// ListHabits implements api.HabitsClient
func (mmListHabits *HabitsClientMock) ListHabits(ctx context.Context, in *mm_api.ListHabitsRequest, opts ...grpc.CallOption) (lp1 *mm_api.ListHabitsResponse, err error) {
	mm_atomic.AddUint64(&mmListHabits.beforeListHabitsCounter, 1)
	defer mm_atomic.AddUint64(&mmListHabits.afterListHabitsCounter, 1)

	if mmListHabits.inspectFuncListHabits != nil {
		mmListHabits.inspectFuncListHabits(ctx, in, opts...)
	}

	mm_params := &HabitsClientMockListHabitsParams{ctx, in, opts}

	// Record call args
	mmListHabits.ListHabitsMock.mutex.Lock()
	mmListHabits.ListHabitsMock.callArgs = append(mmListHabits.ListHabitsMock.callArgs, mm_params)
	mmListHabits.ListHabitsMock.mutex.Unlock()

	for _, e := range mmListHabits.ListHabitsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListHabits.ListHabitsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListHabits.ListHabitsMock.defaultExpectation.Counter, 1)
		mm_want := mmListHabits.ListHabitsMock.defaultExpectation.params
		mm_got := HabitsClientMockListHabitsParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListHabits.t.Errorf("HabitsClientMock.ListHabits got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListHabits.ListHabitsMock.defaultExpectation.results
		if mm_results == nil {
			mmListHabits.t.Fatal("No results are set for the HabitsClientMock.ListHabits")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListHabits.funcListHabits != nil {
		return mmListHabits.funcListHabits(ctx, in, opts...)
	}
	mmListHabits.t.Fatalf("Unexpected call to HabitsClientMock.ListHabits. %v %v %v", ctx, in, opts)
	return
}

// ListHabitsAfterCounter returns a count of finished HabitsClientMock.ListHabits invocations
func (mmListHabits *HabitsClientMock) ListHabitsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListHabits.afterListHabitsCounter)
}

// ListHabitsBeforeCounter returns a count of HabitsClientMock.ListHabits invocations
func (mmListHabits *HabitsClientMock) ListHabitsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListHabits.beforeListHabitsCounter)
}

// Calls returns a list of arguments used in each call to HabitsClientMock.ListHabits.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListHabits *mHabitsClientMockListHabits) Calls() []*HabitsClientMockListHabitsParams {
	mmListHabits.mutex.RLock()

	argCopy := make([]*HabitsClientMockListHabitsParams, len(mmListHabits.callArgs))
	copy(argCopy, mmListHabits.callArgs)

	mmListHabits.mutex.RUnlock()

	return argCopy
}

// MinimockListHabitsDone returns true if the count of the ListHabits invocations corresponds
// the number of defined expectations
func (m *HabitsClientMock) MinimockListHabitsDone() bool {
	for _, e := range m.ListHabitsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListHabitsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListHabits != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListHabitsInspect logs each unmet expectation
func (m *HabitsClientMock) MinimockListHabitsInspect() {
	for _, e := range m.ListHabitsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HabitsClientMock.ListHabits with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListHabitsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		if m.ListHabitsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HabitsClientMock.ListHabits")
		} else {
			m.t.Errorf("Expected call to HabitsClientMock.ListHabits with params: %#v", *m.ListHabitsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListHabits != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		m.t.Error("Expected call to HabitsClientMock.ListHabits")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HabitsClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateHabitInspect()

		m.MinimockListHabitsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HabitsClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HabitsClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateHabitDone() &&
		m.MinimockListHabitsDone()
}
